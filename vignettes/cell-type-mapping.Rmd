---
title: "Cell Type Mapping with NMF Pattern Projection"
author: "Michael Totty"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
    toc_float: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Cell Type Mapping with NMF Pattern Projection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.width = 8, fig.height = 6)
```

# Introduction

This vignette demonstrates how to use **NMFscape** for cell type mapping between datasets using NMF pattern projection. We'll learn NMF patterns from single-nucleus RNA-seq data and project them onto spatial transcriptomics data to identify cell type distributions in tissue.

## Workflow Overview

1. Load reference snRNA-seq data (Zeisel mouse brain)
2. Perform quality control and preprocessing
3. Run consensus NMF to identify robust gene expression programs
4. Load spatial transcriptomics data (Visium mouse coronal section)
5. Project NMF patterns from reference to spatial data
6. Visualize and interpret cell type mapping results

# Setup and Data Loading

```{r libraries}
library(NMFscape)
library(scRNAseq)
library(STexampleData)
library(SingleCellExperiment)
library(SpatialExperiment)
library(scuttle)
library(scater)
library(scran)
library(ggplot2)
library(patchwork)
library(Matrix)
library(pheatmap)
library(org.Mm.eg.db)
library(AnnotationDbi)
```

## Load Reference snRNA-seq Data

We'll use the Zeisel mouse brain dataset as our reference for learning cell type-specific gene expression programs.

```{r load_reference}
# Load Zeisel brain dataset
sce_ref <- ZeiselBrainData()

# Examine the data
cat("Reference data dimensions:", dim(sce_ref), "\n")
cat("Cell types available:", length(unique(sce_ref$level1class)), "\n")
table(sce_ref$level1class)
```

## Load Spatial Data

```{r load_spatial}
# Load Visium mouse coronal section
spe <- Visium_mouseCoronal()

# Examine the spatial data
cat("Spatial data dimensions:", dim(spe), "\n")
cat("Number of spots:", ncol(spe), "\n")
```

# Reference Data Preprocessing

## Quality Control

```{r qc_reference}
# Add mitochondrial gene information
is_mito <- grepl("^mt-", rownames(sce_ref), ignore.case = TRUE)
sce_ref <- addPerCellQC(sce_ref, subsets = list(Mito = is_mito))
sce_ref <- addPerFeatureQC(sce_ref)

# Basic QC metrics
summary(sce_ref$sum)
summary(sce_ref$detected)
summary(sce_ref$subsets_Mito_percent)
```

```{r qc_plots, fig.width=12, fig.height=4}
# QC plots
p1 <- plotColData(sce_ref, x = "sum", y = "detected", 
                  colour_by = "level1class") + 
  scale_x_log10() + scale_y_log10() +
  ggtitle("Library Size vs Detected Genes")

p2 <- plotColData(sce_ref, x = "sum", y = "subsets_Mito_percent",
                  colour_by = "level1class") + 
  scale_x_log10() +
  ggtitle("Library Size vs Mitochondrial %")

p3 <- ggplot(as.data.frame(colData(sce_ref)), 
             aes(x = level1class, fill = level1class)) +
  geom_bar() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Cell Type Distribution") +
  guides(fill = "none")

p1 + p2 + p3
```

## Filter and Normalize

```{r filter_normalize_ref}
# Filter low-quality cells and genes
# Keep cells with reasonable library sizes and low mitochondrial content
keep_cells <- sce_ref$sum > 1000 & 
              sce_ref$detected > 500 & 
              sce_ref$subsets_Mito_percent < 20

# Keep genes expressed in at least 10 cells
keep_genes <- rowSums(counts(sce_ref) > 0) >= 10

sce_ref <- sce_ref[keep_genes, keep_cells]
cat("After filtering - Reference dimensions:", dim(sce_ref), "\n")

# Log-normalize
sce_ref <- logNormCounts(sce_ref)

# Find highly variable genes
dec_ref <- modelGeneVar(sce_ref)
hvg_ref <- getTopHVGs(dec_ref, n = 2000)
```

# Spatial Data Preprocessing

```{r preprocess_spatial}
# Remove spots with very low counts
spe <- spe[, colSums(counts(spe)) > 100]

# Keep genes expressed in at least 10 spots
keep_genes_spe <- rowSums(counts(spe) > 0) >= 10
spe <- spe[keep_genes_spe, ]

cat("After filtering - Spatial dimensions:", dim(spe), "\n")

# Log-normalize
spe <- logNormCounts(spe)
```

## Gene ID Conversion

The reference data uses gene symbols while the spatial data uses Ensembl IDs. We need to convert gene IDs to enable pattern projection.

```{r gene_conversion}
# Convert Ensembl IDs to gene symbols for spatial data

# Get gene symbols for Ensembl IDs
ensembl_ids <- rownames(spe)
gene_symbols <- mapIds(org.Mm.eg.db, 
                      keys = ensembl_ids,
                      keytype = "ENSEMBL", 
                      column = "SYMBOL",
                      multiVals = "first")

# Keep only genes with successful mapping
valid_mapping <- !is.na(gene_symbols)
spe_filtered <- spe[valid_mapping, ]
gene_symbols_clean <- gene_symbols[valid_mapping]

# Update row names to gene symbols
rownames(spe_filtered) <- gene_symbols_clean

# Handle duplicated gene symbols by keeping the first occurrence
dup_genes <- duplicated(rownames(spe_filtered))
spe_filtered <- spe_filtered[!dup_genes, ]

cat("After gene ID conversion - Spatial dimensions:", dim(spe_filtered), "\n")

# Find common genes between datasets
common_genes <- intersect(rownames(sce_ref_hvg), rownames(spe_filtered))
cat("Common genes between datasets:", length(common_genes), "\n")

# Subset both datasets to common genes
sce_ref_common <- sce_ref_hvg[common_genes, ]
spe_common <- spe_filtered[common_genes, ]

cat("Reference data (common genes):", dim(sce_ref_common), "\n")
cat("Spatial data (common genes):", dim(spe_common), "\n")
```

# NMF Analysis on Reference Data

## Consensus NMF for Robust Programs

We'll use consensus NMF to identify stable gene expression programs that correspond to cell types.

```{r consensus_nmf}
# Use the common genes dataset for NMF
# Run consensus NMF across a range of K values
# Using fewer runs for demonstration - increase n_runs for production analysis
sce_ref_common <- runConsensusNMF(sce_ref_common, 
                                  k_range = 8:16, 
                                  n_runs = 50,
                                  density_threshold = 0.5,
                                  verbose = FALSE)
```

## Select Optimal K and Extract Programs

```{r extract_programs}
# Plot stability metrics to select optimal K
plotStability(sce_ref_common)

# Get optimal K
optimal_k <- getOptimalK(sce_ref_common)
cat("Optimal K selected:", optimal_k, "\n")

# Extract consensus gene expression programs
geps <- getConsensusGEPs(sce_ref_common, k = optimal_k)
usage <- getGEPUsage(sce_ref_common, k = optimal_k)

# Examine program dimensions
cat("Gene expression programs dimensions:", dim(geps), "\n")
cat("Usage matrix dimensions:", dim(usage), "\n")
```

## Visualize Gene Expression Programs

```{r visualize_geps, fig.width=10, fig.height=8}
# Plot top genes for each program
plotGEPs(sce_ref_common, k = optimal_k, programs = 1:min(6, optimal_k), n_genes = 15)
```

## Associate Programs with Cell Types

```{r associate_celltypes, fig.width=12, fig.height=8}
# Calculate mean usage for each cell type
cell_types <- sce_ref_common$level1class
usage_by_celltype <- sapply(unique(cell_types), function(ct) {
  cells_ct <- cell_types == ct
  if (sum(cells_ct) > 1) {
    rowMeans(usage[, cells_ct, drop = FALSE])
  } else {
    usage[, cells_ct]
  }
})

# Create heatmap of program usage by cell type
pheatmap(usage_by_celltype, 
         scale = "row",
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         main = "NMF Program Usage by Cell Type",
         angle_col = 45)
```

# Pattern Projection to Spatial Data

## Project NMF Patterns

Now we'll project the learned NMF patterns from the reference data onto the spatial transcriptomics data.

```{r project_patterns}
# Project patterns from reference to spatial data
spe_common <- projectNMFscape(target = spe_common, 
                              source = sce_ref_common, 
                              source_name = "cNMF",
                              target_name = "projected_NMF")

# Check that projection was successful
cat("Spatial data now contains projected patterns:", 
    "projected_NMF" %in% reducedDimNames(spe_common), "\n")

# Get projected usage
projected_usage <- reducedDim(spe_common, "projected_NMF")
cat("Projected usage dimensions:", dim(projected_usage), "\n")
```

## Visualize Spatial Patterns

```{r spatial_visualization, fig.width=14, fig.height=10}
# Create spatial plots for first 6 programs
plot_list <- list()
for (i in 1:min(6, optimal_k)) {
  plot_list[[i]] <- vizDimRed(spe_common, 
                              dimred = "projected_NMF", 
                              program = i, 
                              point_size = 0.3) +
    ggtitle(paste("Program", i)) +
    theme(legend.position = "bottom")
}

# Arrange plots
wrap_plots(plot_list, ncol = 3)
```

## Compare Reference and Spatial Patterns

```{r compare_patterns, fig.width=12, fig.height=8}
# Compare patterns for selected programs
compareProjectedPatterns(source = sce_ref_common, 
                        target = spe_common,
                        source_name = "cNMF",
                        target_name = "projected_NMF",
                        program = 1)
```

# Interpret Cell Type Mapping

## Identify Cell Type-Specific Programs

Based on the program-cell type associations, we can interpret which spatial regions correspond to different cell types.

```{r interpret_mapping}
# Get top cell type for each program based on usage
program_celltypes <- apply(usage_by_celltype, 1, function(x) {
  colnames(usage_by_celltype)[which.max(x)]
})

# Create a mapping table
program_mapping <- data.frame(
  Program = paste("Program", 1:optimal_k),
  Top_CellType = program_celltypes,
  Max_Usage = apply(usage_by_celltype, 1, max)
)

print(program_mapping)
```

```{r cell_type_spatial, fig.width=14, fig.height=12}
# Plot spatial distribution of cell types based on dominant programs
# For each spot, find the program with highest usage
spot_dominant_program <- apply(projected_usage, 2, which.max)
spot_dominant_celltype <- program_celltypes[spot_dominant_program]

# Add to spatial data
colData(spe_common)$predicted_celltype <- spot_dominant_celltype
colData(spe_common)$dominant_program <- spot_dominant_program

# Create spatial plot colored by predicted cell type
spatial_coords <- spatialCoords(spe_common)
plot_data <- data.frame(
  x = spatial_coords[, 1],
  y = spatial_coords[, 2],
  celltype = colData(spe_common)$predicted_celltype,
  program = colData(spe_common)$dominant_program
)

p1 <- ggplot(plot_data, aes(x = x, y = y, color = celltype)) +
  geom_point(size = 0.5) +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(color = guide_legend(override.aes = list(size = 2))) +
  ggtitle("Predicted Cell Types")

p2 <- ggplot(plot_data, aes(x = x, y = y, color = factor(program))) +
  geom_point(size = 0.5) +
  scale_color_discrete(name = "Program") +
  theme_void() +
  theme(legend.position = "bottom") +
  guides(color = guide_legend(override.aes = list(size = 2))) +
  ggtitle("Dominant NMF Program")

p1 / p2
```

# Program-Specific Gene Analysis

## Identify Marker Genes

```{r marker_genes}
# Get top genes for each program
top_genes_per_program <- getTopGEPFeatures(sce_ref_common, 
                                          k = optimal_k, 
                                          n = 10)

# Display top genes for first few programs
for (i in 1:min(3, optimal_k)) {
  cat("Program", i, "(", program_celltypes[i], "):\n")
  cat(paste(top_genes_per_program[[i]], collapse = ", "), "\n\n")
}
```

# Session Information

```{r session_info}
sessionInfo()
```

# Conclusion

This vignette demonstrated how to use NMFscape for cell type mapping between single-nucleus RNA-seq and spatial transcriptomics data. The key steps include:

1. **Reference Analysis**: Performing consensus NMF on snRNA-seq data to identify robust, cell type-specific gene expression programs
2. **Pattern Projection**: Using `projectNMFscape()` to transfer learned patterns to spatial data
3. **Spatial Mapping**: Visualizing projected patterns in spatial context to identify cell type distributions
4. **Interpretation**: Associating NMF programs with cell types and identifying marker genes

This approach enables:
- **Cross-platform integration**: Connect snRNA-seq and spatial transcriptomics
- **Cell type deconvolution**: Identify cell type compositions in spatial spots
- **Robust pattern discovery**: Use consensus NMF for stable gene expression programs
- **Biological interpretation**: Link spatial patterns to known cell types and marker genes

The projected NMF patterns provide a powerful framework for understanding tissue organization and cell type spatial relationships in complex biological systems.